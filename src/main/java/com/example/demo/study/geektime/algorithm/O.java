package com.example.demo.study.geektime.algorithm;

/**
 * 时间复杂度
 * <p>
 * 什么是时间复杂度
 * <pre>
 *     1. 数据结构和算法解决是“如何让计算机更快时间更省空间的解决问题”
 *     2. 因此需要从执行时间和占用空间两个维度来评估数据结构和算法的性能
 *     3. 分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度
 *     4. 复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系
 * </pre>
 * <p>
 * 为什么进行复杂度分析
 * <pre>
 *     1. 和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点
 *     2. 掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本
 * </pre>
 * <p>
 * 如何进行复杂度分析
 * <pre>
 *     1. 大O表示法
 *     <pre>
 *         1. 来源 算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模
 *         2. 特点 以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项
 *     </pre>
 *     2. 复杂度分析法则
 *     <pre>
 *         1. 单段代码看高频：比如循环
 *         2. 多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度
 *         3. 嵌套代码求乘积：比如递归、多重循环等
 *         4. 多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加
 *     </pre>
 * </pre>
 * <p>
 * 常用的复杂度级别
 * <pre>
 *     1. 多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括， O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）
 *     2. 非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括， O(2^n)（指数阶）、O(n!)（阶乘阶）
 * </pre>
 * <p>
 * 所有代码的执行时间T(n) 与每行代码的执行次数成正比. 即: 每行代码的执行次数越多,所有代码的执行时间就越长. 每行代码的执行次数越少,所有代码的执行时间就越短
 * T(n) = O(f(n))
 * T(n)代表代码的执行时间，f(n)表示每行代码执行的次数总和，O表示两者成正比
 *
 * @author gaoruiting
 * @date 2020-10-13
 */
public class O {

    /**
     * 每一行代码都执行着类似的操作：读元素-运算-写元素
     * <p>
     * 假设每行代码执行的时间都一样，为unit_time
     * 第2、3行代码分别需要1个unit_time的执行时间
     * 第4、5行都运行了n遍，所以需要 2n * unit_time 的执行时间
     * 所以这段代码总的执行时间就是 T(n) = (2n +2)*unit_time
     */
    static int cal1(int n) {
        int sum = 0;
        int i = 1;
        for (; i <= n; ++i) {
            sum += i;
        }
        return sum;
    }

    /**
     * 第2、3、4行代码分别需要1个unit_time的执行时间
     * 第5、6行代码循环执行了n遍，需要 2n * unit_time 的执行时间
     * 第7、8行代码循环执行了n^2遍，所以需要 2n^2 * unit_time 的执行时间
     * 所以这段代码总的执行时间就是 T(n) = (2n^2 + 2n +3)*unit_time
     */
    static int cal2(int n) {
        int sum = 0;
        int i = 1;
        int j = 1;
        for (; i <= n; ++i) {
            j = 1;
            for (; j <= n; ++j) {
                sum += i * j;
            }
        }
        return sum;
    }

    public static void main(String[] args) {
        int cal = cal1(10);
        System.out.println("cal = " + cal);
    }
}
